// -*- tab-width:2 ; indent-tabs-mode:nil -*-
//:: cases Pathfinding
//:: tools silicon
//:: verdict Pass

class Ref {

	invariant ar != null ** N > 0 ** M > 0 ** \array(ar,M*N);
	context (\forall* int i;0 <= i && i < M*N ; Perm(ar[i],1/2));
	ensures  (\forall int i;0 <= i && i < M*N ; ar[i]==\old(ar[i]));
	void path(int M,int N, int[M*N] ar){

		par kern(int g = 0 .. M)
		context (\forall* int k ; 0 <= k && k < N ; Perm(ar[g*N+k],1/4));
		{
			par group(int t = 0 .. N)
			requires Perm(ar[g*N+t],1/4);
			ensures t==0 ==> (\forall* int k; 0 <= k && k < N ; Perm(ar[g*N+k],1/4));
			{
				//NOT KNOWN PARAMETERS
				int border = 1;
				int HALO = 1;
				int iteration = 1;
				int cols = 15;
				int rows = 32;

				int BLOCK_SIZE = N;
				int bx = g;
				int tx = t;

				int small_block_cols = BLOCK_SIZE - (iteration*HALO*2);

				int blkX = (small_block_cols*bx) - border;
				int blkXmax = blkX+BLOCK_SIZE-1;

				int xidx = blkX+tx;

				int validXmin = (blkX < 0) ? -blkX : 0;
				int validXmax = (blkXmax > cols-1) ? BLOCK_SIZE-1-(blkXmax-cols+1) : BLOCK_SIZE-1;

				int W = tx-1;
				int E = tx+1;

				W = (W < validXmin) ? validXmin : W;
				E = (E > validXmax) ? validXmax : E;

				boolean isValid = in_range(tx, validXmin, validXmax);

				barrier(group)
				requires Perm(ar[g*N+t],1/4);
				ensures  t==0 ==> (\forall* int k; 0 <= k && k < N ; Perm(ar[g*N+k],1/4));
				{
				}
			}
		}
	}

	boolean in_range(int x, int min, int max){
		return ((x)>=(min) && (x)<=(max));
	}

	int min(int a, int b){
		return ((a)<=(b) ? (a) : (b));
	}
}
